# Assignment 1 (C/C++ + OpenMP)

## Состав проекта
- task1.cpp — Реализуйте программу на C++, которая динамически выделяет массив из 50 000 целых
чисел, заполняет его случайными значениями от 1 до 100, вычисляет среднее значение
элементов массива и корректно освобождает выделенную память.

- task2.cpp — Создайте массив из 1 000 000 целых чисел и реализуйте последовательный алгоритм
поиска минимального и максимального элементов. Замерьте время выполнения алгоритма.

- task3.cpp — Используя OpenMP, реализуйте параллельный поиск минимального и максимального
элементов массива из задания 2. Сравните время выполнения последовательной и
параллельной реализаций.

- task4.cpp — Создайте массив из 5 000 000 чисел и реализуйте вычисление среднего значения
элементов массива последовательным способом и с использованием OpenMP с редукцией.
Сравните время выполнения обеих реализаций.

## Сборка и запуск (g++)
### Task 1
g++ -std=c++17 -O2 task1.cpp -o task1
./task1

### Task 2
g++ -std=c++17 -O2 task2.cpp -o task2
./task2

### Task 3 (OpenMP)
g++-15 -std=c++17 -O2 -fopenmp task3.cpp -o task3
./task3

### Task 4 (OpenMP)
g++-15 -std=c++17 -O2 -fopenmp task4.cpp -o task4
./task4

## Notes (macOS)
В macOS стандартная команда g++ является алиасом для clang++,
который не поддерживает OpenMP.
Для работы с OpenMP используется компилятор GCC, установленный через Homebrew (g++-15).
При необходимости количество потоков можно задать через переменную окружения:
пример: - export OMP_NUM_THREADS=8

## Контрольные вопросы

# 1. В чём отличие динамического массива от статического массива в языке C++?
Статический массив имеет фиксированный размер, он не может изменяться во время выполнения программы.
Динамический массив создаётся во время выполнения программы с помощью new и его размер можно задавать в процессе.
# 2. Что такое указатель и зачем он используется при работе с динамической памятью?
Указатель — это переменная, которая хранит адрес другой переменной в памяти.
При работе с динамической памятью указатели используются для доступа к памяти, выделенной с помощью new, и для управления этой памятью.
# 3. Почему важно корректно освобождать память после использования динамических массивов?
Если не освобождать динамическую память, возникает утечка памяти, из-за которой программа может потреблять больше ресурсов чем нужно.
Корректное освобождение памяти с помощью delete[] предотвращает ошибки и обеспечивает стабильную работу программы.
# 4. В чём разница между последовательной и параллельной обработкой массива?
При последовательной обработке массив обрабатывается одним потоком по очереди элемент за элементом.
При параллельной обработке работа делится между несколькими потоками, которые выполняются одновременно на разных ядрах процессора.
# 5. Что делает директива #pragma omp parallel for?
Директива #pragma omp parallel for автоматически распараллеливает цикл for, распределяя итерации цикла между несколькими потоками для ускорения выполнения.
# 6. Для чего используется механизм reduction в OpenMP?
Механизм reduction используется для корректного объединения результатов, вычисленных разными потоками, например при подсчёте суммы, минимума или максимума элементов массива.
# 7. Почему при параллельном вычислении суммы необходимо использовать reduction, а не обычную переменную?
Если использовать обычную переменную, несколько потоков будут одновременно изменять её значение, что приведёт к гонке данных и неверному результату.
Reduction создаёт локальные копии переменной для каждого потока и безопасно объединяет их в конце вычислений.
# 8. Какие факторы могут привести к тому, что параллельная версия программы будет работать медленнее последовательной?
Параллельная версия может работать медленнее из-за накладных расходов на создание потоков, синхронизацию между ними, малого объёма данных или неэффективного распределения нагрузки между потоками.