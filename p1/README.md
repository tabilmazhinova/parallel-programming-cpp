# Practice 1, Task 3 (C/C++ + OpenMP)

## Состав проекта
- task3.cpp — 
    1.	Реализуйте программу, которая создаёт динамический массив с помощью указателей и заполняет его случайными числами.
    2.	Напишите функцию для поиска среднего значения элементов массива.
    3.	Параллельный подсчёт среднего значения- Используйте OpenMP для параллельного подсчёта суммы элементов и вычисления среднего значения.
        a.	Добавьте директиву #pragma omp parallel for reduction(+:sum) для параллельного суммирования элементов массива.
    4.	Освободите память после завершения работы с массивом.


## Сборка и запуск (g++)

### Task 3 (OpenMP)
g++-15 -std=c++17 -O2 -fopenmp task3.cpp -o task3
./task3


## Notes (macOS)
В macOS стандартная команда g++ является алиасом для clang++,
который не поддерживает OpenMP.
Для работы с OpenMP используется компилятор GCC, установленный через Homebrew (g++-15).
При необходимости количество потоков можно задать через переменную окружения:
пример: - export OMP_NUM_THREADS=8

## Output
    Скрин вывода консоли: output.png
    Блок-схема: bsh-task3.png

## Контрольные вопросы

### 1. В чём основные отличия между массивами и динамическими структурами данных?
Массив имеет фиксированный размер и хранится в непрерывной области памяти.  
Динамические структуры данных могут изменять размер во время выполнения программы и выделяют память динамически.

### 2. Что такое указатель, и как он используется в языке C++?
Указатель — это переменная, которая хранит адрес другой переменной в памяти.  
В C++ указатели используются для работы с динамическими массивами и управления памятью.

### 3. Объясните принцип работы стека и очереди.
Стек работает по принципу LIFO — последний добавленный элемент извлекается первым.  
Очередь работает по принципу FIFO — первый добавленный элемент извлекается первым.

### 4. Каковы преимущества и недостатки односвязных списков по сравнению с массивами?
Преимущество списка в том, что его размер можно изменять и легко добавлять или удалять элементы.  
Недостатки — отсутствие прямого доступа по индексу и больший расход памяти.

### 5. Как правильно освобождать память в языке C++ после работы с динамическими структурами?
Динамическую память, выделенную через `new`, нужно освобождать с помощью `delete`,  
а массивы, созданные через `new[]`, — с помощью `delete[]`, чтобы избежать утечек памяти.

### 6. Почему важно понимать работу с указателями и динамической памятью для параллельного программирования?
В параллельных программах несколько потоков работают с общей памятью.  
Неправильная работа с указателями может привести к ошибкам и некорректным результатам.

### 7. Как использовать reduction в OpenMP для нахождения суммы, минимума или максимума?
`reduction` позволяет каждому потоку вычислять свою часть результата,  
а затем корректно объединяет все значения в одно итоговое.

### 8. Как влияет параллельное программирование на производительность при работе с большими массивами?
При работе с большими массивами параллельное программирование обычно ускоряет выполнение программы.  
При маленьких массивах ускорения может не быть из-за накладных расходов.
