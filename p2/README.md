# Practice 2

## Состав проекта
- task1.cpp — 
    1. Реализация сортировок без параллелизма: Напишите функции для сортировки пузырьком, выбором и вставкой
    без использования OpenMP.
    2. Параллельная реализация с использованием OpenMP: Используйте директивы OpenMP для распараллеливания внешних
    циклов. Протестируйте производительность каждой сортировки на массивах разного размера (например, 1000, 10,000 и 100,000 элементов).
    3. Сравнение производительности: Измерьте время выполнения последовательных и параллельных версий каждой сортировки, используя библиотеку <chrono>. Сравните результаты и сделайте выводы.

## Сборка и запуск (g++)

### Task (OpenMP)
g++-15 -std=c++17 -O2 -fopenmp task1.cpp -o task1
./task1


## Notes (macOS)
В macOS стандартная команда g++ является алиасом для clang++,
который не поддерживает OpenMP.
Для работы с OpenMP используется компилятор GCC, установленный через Homebrew (g++-15).
При необходимости количество потоков можно задать через переменную окружения:
пример: - export OMP_NUM_THREADS=8

## Output
    Скрин вывода консоли: output.png
    Блок-схема: bsh-task1.png

## Контрольные вопросы

### 1. В чём основные отличия алгоритмов сортировки пузырьком, выбором и вставкой?
Сортировка пузырьком сравнивает соседние элементы и постепенно перемещает большие элементы вправо.  
Сортировка выбором на каждом шаге находит минимальный элемент и помещает его в начало массива.  
Сортировка вставкой формирует отсортированную часть массива, вставляя каждый новый элемент в нужную позицию.

### 2. Почему параллельная реализация сортировки вставкой сложнее для выполнения с использованием OpenMP?
Сортировка вставкой имеет сильные зависимости между шагами алгоритма.  
Каждый следующий шаг использует результат предыдущего, поэтому распараллеливание приводит к конфликтам данных и некорректной сортировке.

### 3. Какие директивы OpenMP были использованы для параллельной реализации алгоритмов?
Для параллельной реализации использовалась директива `#pragma omp parallel for` для распараллеливания циклов.  
Также применялись директивы `#pragma omp parallel`, `#pragma omp for nowait` и `#pragma omp critical` для синхронизации потоков.

### 4. Какие преимущества и недостатки параллельной реализации алгоритмов сортировки на CPU?
Преимуществом является сокращение времени выполнения на больших массивах за счёт использования нескольких потоков.  
Недостатками являются накладные расходы на создание и синхронизацию потоков, а также ограниченная эффективность для некоторых алгоритмов.

### 5. Как можно измерить производительность программы в C++?
Производительность можно измерить с помощью библиотеки `<chrono>`, фиксируя время до и после выполнения нужного участка кода и вычисляя разницу.

### 6. Как изменяется производительность сортировок при увеличении числа потоков?
С увеличением числа потоков время выполнения обычно уменьшается до определённого момента.  
После этого ускорение может снижаться из-за ограничений процессора, памяти и накладных расходов на синхронизацию.

### 7. В каких ситуациях параллельная сортировка может быть менее эффективной, чем последовательная?
Параллельная сортировка может быть менее эффективной на небольших массивах,  
при большом количестве синхронизаций или если алгоритм плохо подходит для параллелизации.
